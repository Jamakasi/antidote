# ANTIDOTE DNS

Перенаправлющий DNS сервер ([forwarder](https://ru.wikipedia.org/wiki/DNS-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80)).

### Предназначение

Многие провайдеры, исполняя закон о блокировке ресурсов, делают это в 2 этапа. Блокируют трафик до целевых адресов. Подменяют настоящий ответ на адрес со своей заглушкой т.к. они должны показать пользователю свою страницу с объяснением блокировки и причин.

Обходят блокировки следующими вариантами:

1. VPN всего трафика.
   Самый простой способ. В тоже время имеет недостатки. Уменьшается скорость интернета, увеличиваются пинги. Подавляющее число VPN провайдеров имеют свои ограничения в виде скорости, объема трафика, свои запреты как пример p2p трафика. Кроме того, ломаются сайты в РУ сегменте т.к. они могут ограничивать зарубежный трафик. Ломается геолокация.
2. Списки РосКомСвободы.
   Разные варианты как vpn\bgp antifilter. Части недостатков уже нет, но появляются другие. Огромные списки, для которых нужны ресурсы роутера. Колоссальный ресурсы для "мусорных адресов".
3. Обход через сети i2p\tor.
   Тут вариант для отчаянных или очень упорных. Скорость небольшая, есть ненулевые шансы загреметь по статье.
4. Множество других способов, имеющих как достоинства, так и недостатки.

### Задача для решения проблемы блокировок

1. Нужный трафик вылавливать на лету.
2. Пускать в vpn только нужный трафик.
3. Гибкая вариативность действий с полученными адресами.
4. Поддержка ipv6 трафика.

### Как это работает

Для начала надо понять как провайдер выполняет блокировки и перенаправляет на свою заглушку.
В моем случае это происходит следующим образом:

- Мой клиент выполняет запрос классическим способом по udp на любой DNS сервер. К примеру, запрос на сайт bad-example.org
- Провайдер слушает весь udp трафик на 53 порт. Перехватывает пакет, исследует его, если обнаруживает, что ресурс запрещен, то отвечает А\АААА записью которая ведет на его заглушку lawfilter.bad-isp.ru . Если ресурс не запрещен, то просто игнорирует этот пакет. (забавный факт, некоторые операторы реально все пакеты udp\53 перехватываеют, т.е. можно сделать запрос на несуществующий сервер и провайдер на него ответит, если ресурс в запросе запрещен)
- Клиент получает ответ. Если ответ был отравлен, то в дело вступает вебсервер провайдера.
- Дополнительно провайдер режет соединения по списку ip адресов, дропая запросы\ответы с флагом RST

#### Идея из результата выше

Вклиниться посередине примерно также, как это делает сам провайдер.

- Клиент посылает запрос на сервер antidote
- Antidote пересылает запрос вышестоящему серверу через провайдера
- Antidote получает ответ. Смотрит на адреса, если обнаруживает адрес из заданного списка (ведущие на заглушку провайдера), то пересылает новый запрос вышестоящему серверу минуя провайдера(через vpn). Далее возвращает ответ клиенту, передает список адресов на отработку заданных действий

Сама идея не новая, как минимум еще в 2019 были схожие идеи [[хабр]](https://habr.com/ru/post/467547/)

#### Проверка что такой способ подходит для провайдера

Для начала выяснить хороший, ответ который не отравлен провайдером.
Утилиты dig и jq

```
curl -H 'accept: application/dns-json' 'https://cloudflare-dns.com/dns-query?name=rutracker.org&type=A' | jq .Answer
[
  {
    "name": "rutracker.org",
    "type": 1,
    "TTL": 166,
    "data": "104.21.56.234"
  },
  {
    "name": "rutracker.org",
    "type": 1,
    "TTL": 166,
    "data": "172.67.137.176"
  }
]

```

Правильные адреса 104.21.56.234 и 172.67.137.176
Теперь попробовать перейти на ресурс браузером, отключив любые обходилки блокировок.
Попадаем на заглушку http://lawfilter.ertelecom.ru/
Смотрим консолью браузера IP адрес 188.186.154.88 . Это и есть то что будет искать.

Теперь тестируем. Выполнить запрос через любой DNS сервер

```
dig @1.1.1.1 +noall +answer  rutracker.org
rutracker.org.		600	IN	A	188.186.146.208
```

Запрос был перехвачер и провайдер подсунул адрес своего сервера с заглушкой,это наш случай.

Если же нет, то пробуем сделать запрос через провайдерский dns сервер.

### Компиляция

Необходим пакет утилит go
Перейти в директорию с исходниками и выполнить

```
go build .
```

Результатом будет файл antidote

### Запуск

Дать разрешение на запуск

```
chmod +x antidote
```

Параметры запуска
config /путь/файл (по умолчанию antidote.json)
listen адрес:порт (по умолчанию localhost:8053)

### Конфигурация

Формат файла json.

```
{
	"server": { //Глобальная секция server
	  	"upstream_bad" : { //Плохие DNS сервера идущие через провайдера
	  		"ns": [],      //Список серверов
	  		"strategy": "" //Опционально. По умолчанию "random"
	  	},
	  	"upstream_good" : {//Хорошие DNS сервера идущие минуя провайдера
	  		"ns": [],
	  		"strategy": ""
	  	},
	  	"targets": []      //Цели для поиска
    }
}
```

Типы стратегий для опционального параметра `"ns"`: массив вышестоящих серверов. Указывается в виде IP:PORT. Пример `["1.1.1.1:53","1.1.1.2:53","1.1.1.3:53"]`

Типы стратегий для опционального параметра `"strategy"`:

* `random` - выбирать случайный NS для каждого запроса. В случае недоступности вернется ответ с ошибкой.
* `cycle` - каждый запрос выбирает следующий NS, по достижение последнего перейдет на первый. В случае недоступности вернется ответ с ошибкой.
* `sequence` - запрос через первый NS, если он не ответил или недоступен, запрос через следующий и так до получения ответ или последнего NS. Если последний недоступен то вернется ответ с ошибкой
* `parallel` - одноврмененный запрос через все имеющиеся NS. Результат от самого быстрого, который не вернул ошибки и доступен.

Секция `"targets"`. Цели для поиска внутри ответов от `"upstream_bad"`:

```
{
	"ТИП_ЗАПИСИ": [],
	"actions" : []
}
```

ТИП_ЗАПИСИ - реализованы A и AAAA.
Пример `"A" : ["1.1.1.1","1.1.1.2","1.1.1.3"]`
Пример `"AAAA" : ["fe00::1","fe00::2","fe::3"]`
Параметр `"actions"` набор действий которые необходимо совершить надо адресами которые вернули от `"upstream_good"` если ответ был отравлен и совпал в ТИП_ЗАПИСИ и адресом в них. Выполняются только если ответ был отравлен и только после того как результирующий ответ от `"upstream_good"` вернулся клиенту.

Примеры

```
{
	"A": ["1.1.1.1"],
	"actions" : []
},
{
	"A": ["1.1.1.2","1.1.1.3"],
	"actions" : []
},
{
	"AAAA": ["fe00::1"],
	"actions" : []
}
```

Секция `"actions"`. Список действий, которые необходимо выполнить.
Действия рекурсивны и могут сами включать в себя другие `"actions"`

```
"actions" : [
	{
	"type" : "тип",
	...Параметры типа
	},
	"actions" : [
		{
		"type" : "тип",
		...Параметры типа
		},
		{
		"type" : "тип",
		...Параметры типа
		},
	]
	}
]
```

Экшены.Глобально у каждого следующие параметры:

* `"type"` указание его типа
* `"once"` указание сработать единожды. По умолчанию будет выполнен для каждого адреса А\АААА
* `"actions"` выполнение следующих дествий. Если текущее было выполнено без ошибок.

В экшенах возможны форматируемые строки. Возможные значения для подстановки:

```
{{.Domain}} домен из запроса. На конце всегда будет иметь точку. Пример example.com.
{{.AllAddress}} все адреса из ответа. Пример 1.1.1.1 , 1.2.3.4 , 5.6.7.8 полезно вместе с опцией "once"
{{.Address}} адрес из ответа для текущей итерации. Пример 1.1.1.1
{{.Ttl}}  время жизни из ответа для текущей итерации и текущего адреса. Пример 3600
{{.RecType}} тип записи из ответа. Пример А
```

Значения `"type"` и параметры типов:

#### `log`

Вывести в лог сообщение.

```
{
	"type" : "log",
	"str" : "oncelog  {{.Domain}} {{.AllAddress}} {{.Ttl}} " //Опциональный форматируемый параметр. По умолчанию {{.Domain}} {{.Address}} {{.Ttl}}
}
```

#### `rest`

Выполнить rest запрос.
`method` Обязательный параметр. Возможны `GET` , `POST` `PUT` . Также возможны и другие типы, но они не тестировались.
`login` и `password`  Опциональное поле. Basic http auth . Логин и пароль.
`url` URL до ресурса. Поле форматируемое
В случае с GET запросом необходимо учитывать экранирование символов!
`skiptls` Опциональное поле. Игнорировать сертификаты соединения.
`data` Поле с данными, для всех кроме GET запроса. Поле форматируемое. Content-Type всегда "application/json" . Необходимо экранирование символов, к примеру кавычек обратным слэшем.

```
{
	"type" : "rest",
	"method" : "PUT",
	"login" : "username",
	"password" : "pas$$w0rd",
	"data" : "{\"address\":\"{{.Address}}\",\"comment\":\"{{.Domain}}\",\"list\": \"test-list\", \"timeout\":\"{{.Ttl}}\" }",
	"url" : "https://домен:порт/rest/ip/firewall/address-list"
},
{
	"type" : "rest",
	"method" : "GET",
	"once": true,
	"url" : "https://ntfy.sh/dns/publish?message={{.Domain}}+{{.AllAddress}}&priority=min&tags=+1"
}
```
